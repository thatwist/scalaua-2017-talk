<!DOCTYPE html>
<html>
  <head>
    <title>Demystifying Type Class Derivation with Shapeless</title>
    <meta charset="utf-8">
    <meta name="keywords" content="shapeless,typeclass,scala,derivation" />
    <meta name="description" content="Type class derivation in shapeless explained" />
    <style>
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif);
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      /*a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }*/
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .white-text, .inverse {
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse {
        background: #0F1F2E;
      }
      .inverse h1, .inverse h2, .white-text h1, .white-text h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      .background-cover {
        background-size: cover;
      }
      .remark-code-line-highlighted {
        background-color: royalblue;
      }
      /*****************************************************************************************************************/
      /*************************************   Slide-specific styling   ************************************************/
      /*****************************************************************************************************************/
      #slide-title {
        background-image: url(resources/space-skater.png);
        background-position-y: -9em;
        background-color: black;
      }
      #slide-problem-csv h1 {
        font-size: 5em;
        margin-top: -1em;
        line-height: 2em;
      }
      .bigger-middle-code code {
        min-height: 100px;
        vertical-align: middle;
        line-height: 100px;
        font-size: 1.3em;
      }
      #slide-title h1 {
        font-size: 3.5em;
        font-weight: bolder;
        letter-spacing: 6px;
        line-height: 1.2;
        padding-bottom: 20px;
      }
      #slide-scared {
        background-size: contain;
      }
      #model-domain .left-column {
        /*min-width: 102px;*/
      }
      .live-code1 {
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;
        background-image: url(resources/live-coding.jpg);
        background-position-y: 235px;
        background-size: contain;
        background-color: black;
      }
      #slide-implicits-nose-itches h1 {
        background-size: cover;
        color: #FFFFFF;
        line-height: 1.2;
        font-family: Impact, Arial;
        font-size: 5.5em;
        border-color: black;
        text-shadow: -5px -5px 1px black, 4px -4px 1px black, 4px 4px 1px black, -4px 4px 1px black;
        margin-bottom: 30px; 
      }
      #slide-type-class {
        background-image: url(resources/f-astro-lying.jpg);
        background-color: black;
        background-size: cover;
      }
      #slide-type-class h1 {
        font-size: 3.5em;
        max-width: 5em;
        text-align: right;
        position: absolute;
        right: 50px;
        font-weight: bolder;
        letter-spacing: 6px;
        line-height: 1.2;
        padding-bottom: 20px;
      }
      #slide-debugging {
        background-image: url(resources/astro-cleaner.jpg);
        background-position-y: 30px;
        background-color: black;
        font-size: 1.5em;
      }
      #slide-debugging-alt {
        background-image: url(resources/f-astro-wc.jpg);
        background-size: cover;
        font-weight: bolder;
        text-shadow: 10 10 20px #000;
        font-size: 1.5em;
        /*-webkit-text-stroke-width: 3px;
        -webkit-text-stroke-color: #000;*/
      }
      #slide-debugging-alt h1 {
        margin-top: 0em;
        max-width: 5em;
        line-height: 1.5em;
      }
      #slide-chill-out1 {
        background-position-x: 10%;
      }
      #slide-chill-out2 {
        background-size: 70%;
      }
      #slide-title .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }
      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
      /*****************************************************************************************************************/
      /*********************************************   ADTs table   ****************************************************/
      /*****************************************************************************************************************/
      
      #adts-table {
        width: 600px;
        margin-top: 25px;
      }
      #adts-left, #adts-right {
        margin-bottom: 25px;
      }
      #adts-left {
        float: left;
        width:298px;
        border-right: 2px solid black;
      }
      #adts-right {
        float: right;
        width: 300px;
      }
      .adts-header, .adts-cell {
        padding-left: 30px;
      }
      .adts-header {
        border-bottom: 2px solid black;
        border-top: 2px solid black;
        padding-bottom: 10px;
      }
      .adts-header > h3 {
        margin-top: 0px;
      }
      #adts-left h4:last-of-type, #adts-right h4:last-of-type {
        margin-bottom: 15px;
      }
    </style>
    <!-- <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style> -->
  </head>
  <body>
    <textarea id="source">


name: title
class: center, bottom, white-text

# Demystifying Type Class Derivation in Shapeless

???

Ok, Lets get started
(slightly smile smile smile)

Hi everybody, thanks for coming here, and thanks scalaua cometee and Ruslan in particular for giving me a chance to be here

Let's get started

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
name: problem
layout: true

# Serialize case class?

---

### CSV/JSON/XML/Whatever

```scala
case class User(id: Long, name: String, role: String)

...

def toCSV[T](t: T) = ?
  
```

???

Let's look at this simple User class definition and think a little about simple problem of serialization
Whatever serialization - json/csv/xml - doesn't really matter.

---
count: false

### CSV/JSON/XML/Whatever

```scala
case class User(id: Long, name: String, role: String)

...

def toCSV(u: User) = s"${u.id},{u.name},{u.role}"
```

### Result:

```terminal
scala> toCSV(User(1L, "test"))

res1: String = 1,test
```

???
Well we could do it somehow like this (for CSV) - it is the most simple to think about csv as we don't need to think about field names, right?

---
count: false

### CSV/JSON/XML/Whatever

```scala
case class User(id: Long, name: String, role: Role, addr: Address, score: Double)
sealed trait Role
case class Address(street: String, house: Int)

...

def toCSV(u: User) = s"${u.id}, ${u.name}, ${toCSV(u.role)}, ${toCSV(u.addr)}, ${u.score}"
def toCSV(r: Role) = r match { case a: Admin => s"${a.id}, "; case c; Client => s"${c.id}"
def toCSV(r: Address) = s"${a.street}, ${a.house}"
```

### Result:

```terminal
scala> toCSV(User(1L, "test", Admin(1L), Address("Wall str", 192), 1.0))
res1: String = 1, test, 1, Wall str, 192, 1.0
```

???

What about more complex case? 
it quickly becomes a lot of boilerplate

Usually we have a big and complex domain model
Most of which we would like to be serialized automatically
Common apporaches to such problems are using either
- reflection
- writing serialization explicitly
- code-generation

---
name: problem-csv
class: center, middle, bigger-middle-code
layout: false

# Problem



```scala
def toCSV[T](t: T): String = ???
```



???

<!-- As the first thing, lets think about a problem and why do we really need to derive anything at all and do all this fancy stuff at compile time. The real-life use-case
to better "feel" what type of problems shapeless solves and what is the purpose of it existence. -->

So that would be one of the problems we would like to address today - 
basically being able to define such generic function without writing much boilerplate

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: scared
count: false
class: center, middle
background-image: url(resources/f-astro-brick1.png)

???

<AUDITORY> Is there anybody who has been scared when seen shapeless for the first time <raise your hand>? or maybe confused?

Well, this very first slide is somewhat ?correspond? to what I felt when started with Shapeless
Moving in the dark space - I used some of the functionality provided but I felt like totally miss the whole point
== Well I was able to do all kinds of dirty things with tuples - like merging them together, or substracting
but I was like - 'Man, you miss the whole point', and then when I looked into shapeless codebase - I wanted to decide on suicide
like this poor guy

well its not that plain - but there are certain technics which if your are not aware of - make you feel very confused and dumb

But then I realized there is nothing super-special there, it's not a magic.

But I was very impressed by the beaty and elegence of this library at the same time

So if you feel confusion - then leave it - there is no magic in here - it is just a plain scala code. Well not that plain
albeit exploiting some of the interesting technics - some of them we will try to demistify today.
 <!-- we will try to demistify some of the core ?capabilities|? and som -->
This is not going to be an expert guide - I'm not an expert in it - I will just share with you a way to approach to understand the library
Then you hopefully will feel yourself more comfortable with itbeing able to explore more advanced features


<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: agenda
class: left

# Agenda

* #### Intro
* #### ADTs everywhere
* #### Products & Coproducts
* #### Being Generic
* #### Type Classes FTW
* #### Derivation
* #### `[live-code]`
* #### Capturing field names
* #### `[live-code]`

???

<!--
The idea of derivation is used in many libraries and itself it is considered somewhat "library-thing"?? - like shapeless is made for those who write libraries - it is too complex for regular production usage

// The level of a talk would be around middle scala-dev who just started to investigate shapeless library or at least have strong understanding what implicits in scala do and is aware of basic capabilities of a type system in scala.
 -->
 But once you get familiar with technics and approaches - you start seeing use cases everywhere


First of all we will try to go through some basics and kind-of try to look at the ADT types and have a look at them from somewhat different,higher perspective
and then we will try to do some livecoding and will take a look at some of the aries of application of those patterns - basically where we can use it what is value?

I hope I will bring you some useful and some understanding of the core concepts and possibilities type-driven development can bring you in scala.

<li><h2> To understand what I'm talking about you should have at least a basic understanding of implicits in scala
Without that knowledge this talk probably will not make a lot of sense to you

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
layout: true
---
name: model-domain
class: center, middle, inverse

# How do we model our domain?

???

In order to get there - lets start from the veryvery simple thing - 
How do we model our domain in scala? What are the basic instruments we usually use to represent objects from the real-life?
<wait for answer>

---
count: false
name: model-domain
# How do we model our domain?

.left-column[
  ### case class / sealed trait
]
.right-column[
- #### case class
- #### sealed trait

```scala
case class User(id: Long, name: String,
                  active: Boolean, role: Role)

sealed trait Role

case class Admin(id: Long, special: Boolean)
case class Client(id: Long)
```
]

???
They are really nice and declarative - they are concise - there is no boilerplate as in Java
What are the main problems with case classes? - They are very explicit - the name is bounded to representation
Its hard to compose them - it is really hard to extend them and it quickly becomes a lot of boilerplate (you can define common trait and stuff)

the problem with sealed is that it has a scope of one source file, its not that easy to create custom sealed families or extend existing ones
you can of course remove 'sealed' but then you loose the whole idea of being sealed

What are the other options? more generic?

---
count: false

# How do we model our domain?

.left-column[
  ### case class / sealed trait
  ### TupleN / Either
]

.right-column[

- #### TupleN[...] extends Product
- #### scala.Either / cats.Xor / scalaz.\/

```scala
type User = (Long, Sting, Boolean, Role)


type Role = Admin \/ Client
type Admin = (Long, Boolean)
```
]

???
Going a little bit further - 
at this point we abstracted over types of the fields - those are encoded now into type parameters
Now we can write generic functions parameterized by types of

we are ok with that, but we are not ok with the "size" of the data, we want to abstract over the size of the case/class/tuple

we want to be able to abstract over 'size' or 'arity' of that - kind of - move that N into type parameter

---
count: false

# Abstracting over arity

.left-column[
  ### case class / sealed trait
  ### TupleN / Either
  ### HList / Coproduct
]

.right-column[

- #### HList
- #### Coproduct

```scala
type User = Long :: Sting :: Boolean :: Role :: HNil

type Role = Admin :+: Client
type Admin = Long :+: Boolean :+: CNil
type Client = Long :+: CNil
```

```scala
val sandy: User = 1 :: "Sandy" :: true :: admin :: HNil
val admin: Role = Inr(2 :: HNil)
```
]

???
here come heterogenous list and coproduct

as the most generic form we can get here

yeah, just a little bit later we will see what we can do with them

<!-- ------------------------------------------------------------------------------------------------------------ -->
---

name: adts
layout: false
class: left

## ADT .red.bold[*]

<div id="adts-table">
    <div id="adts-left">
        <div class="adts-header"><h3><strong>AND</strong> types</h3></div>
        <div class="adts-cell"><h4>case class</h4></div>
        <div class="adts-cell"><h4>Tuple     </h4></div>
        <div class="adts-cell"><h4>HList     </h4></div>
    </div>
    <div id="adts-right">
        <div class="adts-header"><h3><strong>OR</strong> types</h3></div>
        <div class="adts-cell"><h4>sealed trait</h4></div>
        <div class="adts-cell"><h4>Either      </h4></div>
        <div class="adts-cell"><h4>Coproduct   </h4></div>
    </div>
</div>

```scala
case class User(id: Long, name: String, active: Boolean, role: Role)

sealed trait Role
case class Admin(id: Long, special: Boolean)
case class Client(id: Long)
```

.footnote[.red.bold[*] Stands for Algebraic Data Type]

???

User is = id AND name AND active AND role
Role is = Admin OR Client
I think that should be pretty straightforward

<AUDIENCE> Is everybody clear with that?

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
exclude: true
name: adt-arity
layout: false

# What about ADTs?

Abstracting over arity
--
exclude: true
count: false

## _How to abstract over arity of a product?_

kind-of move this TupleN to Tuple[N]


???

so the arity is basically number of fields
Well we will see later

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: hlist

<h1>HList</h1>
<!-- <h1><span style="color: #DDD">Product</span> HList</h1> -->

```scala
val hlist = 1 :: "one" :: 1L :: HNil
// res0: shapeless.::[
//          Int,shapeless.::[
//              String,shapeless.::[Double,
//                  shapeless.HNil
//              ]
//          ]
//      ] = 1 :: "one" :: 1L :: HNil

hlist.head // Int
hlist.tail.head // String
hlist.tail.tail.head // Long
```
---
count: false
template: hlist

### HList Definition:

```scala
sealed trait HList

case class ::[H, T <: HList](head : H, tail : T) extends HList // HCons

case object HNil extends HList
```

???
>

---
count: false
template: hlist

### List Definition:

```scala
sealed trait List[+A]

case class ::[A](head: A, tail: List[A]) extends List[A]

case object Nil extends List[Nothing]
```

???
>

So lets take more precise look at HLists

<AUDITORY> Is anybody here who has never heard of HList?

starts from the very simple idea of recursive types
something beautiful about FP - the simpler idea is the better it composes

This is a way to abstract over arity

So this basically a type recursion
and this is something you can see in a 
btw in scala 2.12 the annotation @showAsInfix was added which enables infix type printing in console
(move below - after HList or when complex structure goes) going further for a minute - this is something which can help debugging

naming Product <-> HList
The idea behind HList is very very simple - .. recursive types
The capabilities of type system in Java is enough to implement this - it will take you 20-30 lines
or any other language - the plus of scala is that it allows infix type syntax which make possible following notation (A1 :: A2 :: … :: HNil)

<starts from>
So the instance of HList basically looks like this: (probably most of you saw):

And you can do all kinds of dirty things with that

The form it is written here - is using infix syntax which makes them really nice to work with in scala
and it looks very similar to regular scala List builder

<trait definition>

If we would deconstruct it into regular prefix form, it would look like:
```scala
val user =
::(1L,
  ::()
)
```

So, the infix type constructing syntax enables this beautiful style, 


so you can put there different types of things and then can do all kinds of dirty things with it like
h.get(_2): T // 

mapping over with functions depending on type

rise your hands who have never heard of HList?

---
name: coproduct

# ~~CoHList~~ Coproduct

Once you nailed a HList part - for Coproduct it is quite similar

```scala
sealed trait Coproduct

sealed trait :+:[+H, +T <: Coproduct] extends Coproduct

case class Inl[+H, +T <: Coproduct](head : H) extends :+:[H, T]
case class Inr[+H, +T <: Coproduct](tail : T) extends :+:[H, T]

sealed trait CNil extends Coproduct

```

???
Unlike HNil - CNil doesn't convey any information - so this achieved through not having any value for CNil (sealed trait)

>
<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: generic1
class: inverse, middle, center
count: false

# Generic

---
name: generic2

# Generic

```scala
import shapeless.Generic

case class User(id: Long, name: String, active: Boolean)

val generic = Generic[User]

// res0: shapeless.Generic[User]{type Repr = shapeless.::[Long,
//  shapeless.::[String,
//      shapeless.::[Boolean,
//          shapeless.HNil
//      ]
//  ]
//]}
```

---
count: false
name: generic3

# Generic

```scala
trait Generic[A] {

  type Repr

  def to(value: A): Repr

  def from(value: Repr): A
}
```

---
count: false
name: generic3

# Generic


```scala
import shapeless.Generic

case class User(id: Long, name: String, active: Boolean)

val generic = Generic[User]
// res0: shapeless.Generic[User]{type Repr = shapeless.::[Long,
//  shapeless.::[String,
//      shapeless.::[Boolean,
//          shapeless.HNil
//      ]
//  ]
//]}

val user = User(1L, "Josh", true)

val genericUser = generic.to(user)
// genericUser: generic.Repr = 1 :: Josh :: true :: HNil

generic.from(repr)
// res1: User = User(1,Josh,true)
```

<!-- ------------------------------------------------------------------------------------------------------------ -->

???

And the core abstraction which enables it in shapeless is something called Generic


<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: type-class
class: top, white-text, right
count: false

# Type Class pattern

???

Well, as you can see - an astronaut is a little bit overwhelmed here
but thats understandable, well..
---

# Type Class pattern

```scala
trait CSVSerializer[A] {

  def apply(a: A): String
}
```

???

This is vere functional type of polymorphism
instead of overloading in OO style

if you just recently switched from Java then think about Comparable and you will understand typeclasses

The essential parts of typeclass pattern are

- parameterized interface
- instances for concretized types (implicits) - usually put in companion object
- implicit parameter - type boud / context bound

When you see this huge deifinition - start from looking for some abstract parameterized interface with one or few methods
this is a way to distinguish a typeclass pattern
All these stuff enclosed in companion object
Why in companion object you may ask - because it is the scope where compiler will search for implicits without special imports


The essential parts of type-class definition are:

lets leave HLists stuff on the side just for a moment - the type class pattern

The idea behind type-class pattern is very similar (in some sense) to implicit class pattern
Came from haskell

Ordered(Ordering)

For those of you who is not familiar with type-class pattern - you can think about implicit class
the very functional type of polymorphism - when we extend functionality of some class without touching it
on the contrary of inheritance in OOP polymorphism
implicit class on steroids - what if you need to provide different implementations depending on some polymorphic type?
lets look at the following:
trait CSVSerializer[A] {
  def serialize(a: A): String
}
as you can see there is no implicits or anything scary here - it just very abstract definition of some functionality
you capture very basic functionality into interface

then lets define some instances - lets say we need to serialize Int

Type classes are all over the place
The most familiar to everybody should be Ordering

All of the FP primitives like Functor/Applicative/Monad are defined in popular FP libraries like scalaz/Cats
using this pattern



Whenever you see a bunch of implicits under some 'object' namespace producing values of the same parameterized trait
you can distinguish a Type Class pattern
And again, you should start to read that code from that trait definition - do not pay a lot of attention to implicits


????????
починати з початку а не з кінця - нахріна це потрібно? проблематика?

академічно дуже

що таке shapeless??

малюнки

sidebar with current item

---
count: false

# Type Class pattern

```scala
object CSVSerializer {

  def apply[A](implicit serializer: CSVSerializer[A]): CSVSerializer[A] = serializer

  implicit class WithEncode[A](a: A) {
    def serialize(implicit serializer: CSVSerializer[A]) = serializer.serialize(a)
  }
}
```

thats it - this is the basic idea - once you start using type-classes and build your functionality around it
at some point you will have to deal with ADTs

You just need to start looking at the definition from the trait - typeclass definition
and there can be a bunch of other stuff with implicits resolution helpers - apply,implicit class - but the main thing to look at is trat definition

and then comes implicit instances - 


<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: simulacram

# https://github.com/mpilquist/simulacrum

```scala
@typeclass trait CSVSerializer[A] {
  @op("§") def serialize(a: A): String
}
```

???

This macro produces quit a lot of noise but that is considered as a full canonical type-class pattern implementation in scala
btw in Haskell - type classes are first-class language primitives which makes them much easier to work with


First-class construciton in Haskell 98 - Eq, Ord, Enum, Bound, Show, Read
THere is a library named simulacrum which enables it fo;r scala
and btw Cats uses it - all of the type classes in that library are defined using this macro annotation
Well, it is just simple macro but maybe someday it could start to be a part of scala language reserved word
the same way we have `case class` generating a whole bunch of stuff with hascode equals getterss setters and stuff
I bet there is probably some PR for that already

Really nice way for expressing
although it's obvious that this is just a workaround and kind-of temporary solution until real first-class support will be added. I believe


--
count: false

```scala
trait CSVSerializer[A] {
  def serialize(x: A, y: A): A
}

object CSVSerializer {
  def apply[A](implicit instance: CSVSerializer[A]): CSVSerializer[A] = instance

  trait Ops[A] {
    def typeClassInstance: CSVSerializer[A]
    def self: A
    def §(y: A): A = typeClassInstance.append(self, y)
  }

  trait ToCSVSerializerOps {
    implicit def toCSVSerializerOps[A](target: A)(implicit tc: CSVSerializer[A]): Ops[A] = new Ops[A] {
      val self = target
      val typeClassInstance = tc
    }
  }
  object nonInheritedOps extends ToCSVSerializerOps

  ...
```

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
layout: false
name: live-code1
class: white-text, live-code1
count: false

# deriving serializer

[live-code]

???

All right so lets return to our example with CSV encoding and lets try to do some live-coding

.. live code
basic instances for csv encoding
implicitly
deriving instance for HList
problem with Aux

Lets look at another example

<livecode>

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: aux

# Aux Pattern

```scala

scala> trait Foo { type T }
// defined trait Foo

scala> def f(foo: Foo, t: foo.T) = ???

* <console>:13: error: illegal dependent method type: parameter may only be
*                              referenced in a subsequent parameter section
*       def f(foo: Foo, t: foo.T) = ???
             ^
scala>
```

--
count: false

## Solution:

```scala
scala> trait Foo { type T }
// defined trait Foo

scala> type Aux[T0] = Foo { type T = T0 }
// defined type alias Aux

scala> def f[T](foo: Aux[T], t: T) = ???
// f: [T](foo: Aux[T], t: T)Nothing

```

???

The reason of existence of this pattern is rather simple but you might be confused if you don't know about it
and just seeing Aux all over the place

---
name: aux1

# Aux Pattern

```scala
  type Aux[T, Repr0] = Generic[T] { type Repr = Repr0 }
```

???

<livecode>

Aux pattern is something which comes naturally from constrains

The rule of thumb is - 
Whenever you need to summon instance with dependent type like `Foo[???] { type B = ??? }`
you need to use type alias -> Aux pattern

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: live-code2
class: live-code1
exclude: true
count: false

.. live code
instances for products
coproducts

???

<livecode>

Instances for Coproducts can be derived in the similar way using the same technics as with HLists
Once you understand how to use those technics with HList - there is nothing special with Coproducts



<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: divergence

# Implicit divergence

### nested structure

```scala
case class Account(id: Long, user: User)
case class User(id: Long, name: String, active: Boolean)
```

```scala
  /*1*/ CSVSerializer[Account]
  /*2*/ CSVSerializer[::[Long, ::[User, HNil]]]
  /*3*/ CSVSerializer[::[User, HNil]]
  /*4*/ CSVSerializer[User]
* /*5*/ CSVSerializer[::[Long, ::[Sting, ::[Boolean, HNil]]]] // failed

// diverging implicit expansion for type xyz.codefastdieyoung
//        .CSVSerializer[Long :: String :: Boolean :: shapeless.HNil]
```

the compiler sees the same type constructor twice and 
      the complexity of the type parameters is _increasing_...

---
count: false
name: lazy

# Lazy!

```scala
  import shapeless.Lazy

  implicit def HConsEncoder[H, T <: HList](implicit
*   hEncoder: Lazy[Encoder[H]],
    tailEncoder: Encoder[T]
  ): Encoder[H :: T] = { t =>
    s"${hEncoder(t.head)}, ${tailEncoder(t.tail)}"
  }
```

wrap diverging implicit parameter...

???

Lazy to the rescue

---
name: shapeless
class: white-text
background-image: url(resources/f-astro-shapeless.jpg)

# shapeless

???

So, this is what derivation means - 
using type-classes we are able to derive instances for composite type while having instances for

And what shapeless does is basically providing an instruments to work with ADTs in a generic way
provides us a possibility to abstract over arity (number of arguments)
and write functions like toCSV in a more generic fasion

There are a couple of other minor items/possiblities in the library 
but the main one - is to asbtract over arity

---
count: false
layout: false
name: generic-programming
class: bigger-middle-code
exclude: false

# Generic programming

```scala
def fmap[A](f: A => B): F[B] = ???
```

???

At this point we can give some definition to what generic programming is
and speaking very simple - whenever you use generics you do Generic programming
and that means you do a kind of programming when you write algorithms in terms of not-yet defined types

In such ways we are generalizing over common properties of types and functions
However In some cases it's easier to abstract over particular property - like type of the field of the User class
in other cases - it's harder like arity - 

<!-- .......
concretising too early - lean software development methodologies - make a decisions as late as possible
 -->

one of those techincs - is type definition
very simple at first - it enables a lot more sophisticated in connection with implicits


<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: debugging
class: white-text, background-cover
count: false

# Debugging implicits

???

- once you have a lot of nested fields - its a problem - compiler will end up with non-descriptive messages ...
- implicitly / reify

---
name: debugging-alt
class: white-text, background-cover
count: false

# Debugging implicits

---

# Debugging implicits

- ### implicitly
- ### the
- ### reify
- ### @showInfix
- ### and of course - IDE short-cuts to lookup implicit values

???

at least it fails at compile time and will not produce runtime errors, (unless you are mixing into different implicit and you don't how to lookup them in IDE)


of course - you should know
otherwise it becomes a pain the ass to lookup which implicit value has been supplies into the method
for those who are <in Idea - these are - <show>>
Once you know these shortcuts - you should feel comfortable working with type-classes, AND you shoudl use IDE which supports this

otherwise it makes you feel something like that...

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
name: implicits-nose-itches
background-image: url(resources/itch.jpg)
class: bottom, center, background-cover

# MY NOSE ITCHES

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
layout: true

# Generic

### what if we would encode Repr as type parameter rather than type member?
---

```scala
trait Generic[A, Repr] {
  def to(value: A): Repr
  def from(value: Repr): A
}
```

---
count: false
name: generic-shape

```scala
trait Generic[A] {
* type Repr
  def to(value: A): Repr
  def from(value: Repr): A
}
```

then we can't reuse it in some other context

???

This is what enables
And enables us to derive type-class instances for arbitrary case-classes

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
class: live-code1
layout: false

# product Last
[live-code]

???

Ok, lets try to do something interesting with HLists and Type Classes

 << prepared with type class and test printlns >>

 - define apply

 - define HNil size

 - define HCons size
 - <AUDITORY> ADVICE WITH generic.AUX?????

 - ?? what else - we can derive instance of this class for all Products (case classes)
 - example (tuple is a Product itself )

 - Java8 functional interfaces -  I think its really great, makes cleaner syntax
 <<<<<  PROBABLY One of the few usefull things of JAVA8  >>>>>

 - preferrable style would be to put implicits into companion object - because this is default scope of where

 <AUDITORY>
 <AUDITORY> Does everybody follow me at this point? Is everything clear with this example?
 

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false

# __ shapeless.ops.hlist._ __

> operations over generic representations

* ## Size
* ## Last
* ## Reverse
* ## Partition
* ## Filter
* ## ...

???

In fact, the functionality we have just defined - already exists in shapeless library
And there are a whole bunch of other stuff - the definition of 

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: tuple-ops

# Tuple ops

```scala
(1,2,3).head
// res0: Int = 1

(1,2,3).tail
// res1: (Int, Int) = (2,3)

(1,2,3).last
// res2: Int = 3

(1,2,3).size
// res3: Int = 3

// todo - dome better examples
```

???

Thats where all those tuple extensions come from

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
class: inverse, middle, center
count: false

# Dependent types

### type members
### implicit resolution
### neat syntax
<!-- - neat syntax enabled by implicit's sugar -->

???

this makes scala
todo

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: dep-fns

# Dependently typed functions

We've already seen a Last, Init type classes (or something else)
Lets think about application of them and remind classic scala function definitions


<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
template: dep-fns

```scala
  trait Function0[R] {

    def apply(): R
  }

  trait Function1[T, R] {

    def apply(t: T): R
  }
```

---
count: false
template: dep-fns
```scala
  trait DependentFunction0 {
*   type Out
    def apply(): Out
  }

  trait DependentFunction1[T] {
*   type Out
    def apply(t: T): Out
  }
```

## Now its possible to have one function __DEPEND__ on other during implicit resolution

???

The idea is to have a type inside a trait with apply - we can output type in some other

So the only thing has been changed here is that we moved the result type of the function into type field
That means we can build a chains of dependant functions


<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
exclude: true

# Going a little bit further

- values dependent on types
- types dependent on types (type constructors) higher-kinded types
- types dependent on values (dependent types)

--
exclude: true
count: false
## Kinds

\* -> \*
\* x \* -> \*
https://youtu.be/hzf3hTUKk8U?t=634


--
exclude: true
count: false
```scala
val id: Int => Int
```

```scala
type Id[X] = X
```

--
exclude: true
count: false
```scala
  trait λ { type ap[_ <: λ] <: λ }
  type I = λ{type ap[X<:λ] = X }
  type K = λ{type ap[X<:λ] = λ{type ap[Y<:λ] = X }}
  type S = λ{type ap[X<:λ] = λ{type ap[Y<:λ] = λ{type ap[Z<:λ] = X#ap[Z]#ap[Y#ap[Z]] }}}
```

???
>
In order to provide some even more context - lets look at the , and try to kind of categorize these

/?do not talk about something youre not fully familiar with//// btw - such categorization comes from mathematic logic and type theory  - there is something called Lambda cube ////


<!-- ------------------------------------------------------------------------------------------------------------ -->
---
class: inverse, middle, center
count: false

# LabelledGeneric

<!-- ------------------------------------------------------------------------------------------------------------ -->
---

# What has been lost here?


```scala
type User = Long :: Sting :: Boolean :: Role :: HNil

type Role = Admin :+: Client
type Admin = Long :+: Boolean :+: CNil
type Client = Long :+: CNil
```

```scala
val sandy: User = 1 :: "Sandy" :: true :: admin :: HNil

val admin: Role = Inr(2 :: HNil)
```

???

Ok, lets return to this User class representation

<AUDITORY> Has anybody noticed that something is missing here? Which part of initial User class definition has been lost here?
<AUDITORY> Any thoughts?
Which essential part of a User class has been lost here?

---
count: false

# Capture field names?

```scala
//             label      label          label
//              ||         ||             ||
//              \/         \/             \/
case class User(id: Long, name: String, active: Boolean)
//          /\
//          ||  
//         label  
```

???

Right, We've lost information about field names,.. (and class name as well)
In case of CSV serialization - it is sufficient, but if we need to serialize to Json we need to perserve field names as well

---
count: false

# LabelledGeneric

```scala
val user = 1 :: "Josh" :: true :: "admin" :: HNil

val userLabelled =
      ("id" ->> 1) ::
      ("name" ->> "Josh Travis") ::
      ("active" ->> true) ::
      ("role" ->> "admin") :: HNil
```

```scala
trait LabelledGeneric[T] {
  type Repr

  def to(t : T) : Repr

  def from(r : Repr) : T
}
```

???

To have a full representation of the real-world object we need to preserve information about field names
meta information - field names. (think about jdbc ResultSets and database schema)

There is really neat syntax for this in shapeless - using that double arrow operator
But what lies behind this double arrow??

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: phantom types
layout: true

# Accessing field name at runtime

---

.left-column[
  ### Singleton types
]

.right-column[
  ```scala
  object Foo

  Foo.type
  // res0: Foo.type

  1.narrow
  // res7: Int(1) = 1

  true.narrow
  // res8: Boolean(true) = true

  "hello".narrow
  // res9: String("hello") = hello

  // and so on...
  ```
]
--
count: false
.right-column[
  ```scala
  // scala 2.12
  * val int42: 42 = 42
  * val int42: 42 = 41 // will not compile
  ```
]

---
count: false

.left-column[
  ### Singleton types

  ### Type tagging
]

.right-column[ 

  ```scala
  val tagged: String with Int = "1".asInstanceOf[String with Int]
  val str: String = tagged

  val int: Int = tagged // runtime ClassCastException
  ```

  ### Shapeless:

  ```scala
  import shapeless.labelled.{KeyTag, FieldType}
  import shapeless.syntax.singleton._

  val name = "Josh Travis"

  val labelledUserName = "name" ->> name
  // res1: labelledUserName: String with shapeless.labelled.KeyTag[String("name"), String] = "Josh Travis"
  ```
]

???

There is one trick we can do with types in scala

---
count: false

.left-column[
  ### Singleton types
  
  ### Type tagging

  ## Putting together
]

.right-column[ 

  ```scala
  val josh = "Josh Travis"
  val labelledUserName = "name" ->> josh
  // res6: String with shapeless.labelled.KeyTag[String("name"), String] = "Josh Travis"
  ```

  1. #### creates singleton type
  ```scala
                       String("name")
  ```

  2. #### creates tag with this type
  ```scala
                KeyTag[String("name"), String]
  ```

  3. #### tags original type with it
  ```scala
    String with KeyTag[String("name"), String]
  ```
]

---
count: false
name: witness
exclude: false

.left-column[
  ### Singleton types
  
  ### Type tagging

  ## Witness
]

.right-column[ 

  ### How can we retrieve the field name at runtime?

  ```scala
  val labelledUserName = "name" ->> "Joshua Travis"

  def getFieldName[K, V](value: FieldType[K, V])
    (implicit witness: Witness.Aux[K]): K =
          witness.value
  def getFieldValue[K, V](value: FieldType[K, V]) = value

  getFieldName(labelledUserName)

  // res15: String = name

  getFieldValue(labelledUserName)

  // res10: String = Josh Travis
  ```
]

???

So now we have our field tagged with information about its name
But that exists only at compile time - it is encoded through singleton type

How can we get a field name at runtime?
Only then it becomes useful for us!

Here comes shapeless Witness

???????
btw - I'm using TypelevelScala2.12
btw - scala2.12 and typelevel scala supports singleton types already

---
## Again

--
count: false

```scala
A with B
```
--
count: false

```scala
type Field = A with KeyTag[String("..."), B]
```
--
count: false

```scala
val witness = implicitly[Witness.Aux[Field]]
```
--
count: false

```scala
witness.value = "..." // field name
```

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
layout: false
name: json-serialize

# Serialize json at compile time

### [github.com/fommil/spray-json-shapeless]()
### [github.com/circe/circe]()

```scala
val user = User(1, "Jimmy", true, "admin")

val json = user.toJson
```
Gives:
```json
{
  "id": 1,
  "name": "Jimmy",
  "active": true,
  "role": "admin"
}
```

???

spray-json - Probably the most concise json serialization library - it uses exactly the same technics of derivation

We will not
once you have understand the previous example with CSV encoding - the Json encoding is pretty straightforward
using the same technics deriving instances for ADTs with just added field labels

Instead we will try to do something really ambitious:

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
class: live-code1
name: live-code-migration
count: false

# case class migrations
[live-code]

???

...
.. <livecode> chaining dependent type functions (with Aux)

in fact dependent function in scala 2.12 has this one-method funciton first-class support
which makes them look as regular function

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
exclude: true

# Monoid typeclass derivation

Just to tell you a few words more about what you can actually do with all of this

??? We will not reinvent the wheel and will use a Monoid type class from the famous Cats library


<!-- ------------------------------------------------------------------------------------------------------------ -->
---
exclude: true

# use-cases

other real-life use cases
not only for designing new libraries
any kind of typesafe ADT serialization/deserialization
any 

until we have some time - lets go through some of the other use cases or other operations you can do
you can do your own implementation of 
ops
Poly


<!-- ------------------------------------------------------------------------------------------------------------ -->
---
exclude: true
count: false

# TypeClass Type Class

???

We've already seen a derivation for

<confused astronaut>

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: real-life
background-image: url(resources/back-to-earth.jpg)
class: top, white-text, background-cover
count: false

# Back to Earth Again...

???

WELL,
many people consider shapeless as a tool a library  to use to construct other libraries
I’m not particularly agree
The essence of shapeless, from my point of view, is to use it in a very minimalistic way
The use-cases are all over the place and in your current project you can find numerous of places
where you can reduce boilerplate

as there are a lot of 

I don't think that HList and Coproducts should be used to model entire domain - well it can
but from my perspective you should always choose the minimal abstraction - as premature optimizations are a root of all evel as we all know
the power if it is being able to convert representation while you need do some stuff and then convert back



i want to pay your attent to the very minimalistic usage of shapeless api - and its usually like that

this is what makes shapeless neat and elegant
and this small thing enables generality
and makes scala so versatily

<!-- ------------------------------------------------------------------------------------------------------------ -->
---

# Issues

* ## Compilation Times
  ** 
  ** 
* ## inductive implicits
   * ### typelevel fork 2.11+
   * ### `-Yinduction-heuristics`
* ## runtime overhead
* ## ...

---
exclude: true
count: false
# typesafe scala 2.12

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: conclusion
background-image: url(resources/f-astro-car.jpg)
class: white-text
count: false

# Conclusion

???

- todo
- always choose a minimal abstraction needed
- So HLists and Coproducts are good for certain things especially for building rich api 
but they might not be that good as a main building blocks for your applications
-- Here we can reference some of the core principles of lean methodologies
  choose minimal abstraction
  be driven by domain
  preliminary optimizations/generalizations as they are a root of all evil
they are not


Again - HList/Coproduc - are not an alternative wayof modelling your domain
They are extremely powerful representations of your ADTs that you can use to perform very tricky things at compile time
like fully typesafe serialization

When going for the purity you may miss some very important thing - “practicality”
When you are in production you still should keep something in your mind -  always be driven by the domain needs and business goals
unless you are making a research or building next generation of astronauts' <...>
we are all tech guys and sometimes are too idealistic and “out-of-this-world” with our experiments
Sometimes experiments may lead to 
I think its essential to keep in mind real use-cases
which makes really very bad advert for such libraries and methodologies like shapeless

Such a powerful tools doesn’t mean you have to use them everywhere in every possible situation
in fact - Practical usage shoudl always be very concise - that makes such libraries and approaches so beautyful

 end: Well, scala exposes really great possibility of combining type-dependent with less-type safe mutable 


somebody would say that implicits are just some syntactic sugar - well yes and no - if 

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: whats-more
class: inverse, middle, center

## Poly
## ops
## Lenses
## TypeClass type class
## Peano numbers
## Utils (the, not-compile, Typable)

???

There are a whole bunch of other stuff

- generic ops - to 
- TypeClass - (yes, it's not a joke) to automate instances derivation for case classes for arbitrary Type Classes
- peano - you can use them for instance to manipulate the size of HList at compile time or get type of the n-th element at compile time
- lenses - much less-boilerplate then for instance scalaz.

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
name: astronauts-guide
background-image: url(resources/astronauts-guide.png)
???

you may wonder - what are those astronaut's pictures scattered across the entire presentation - well thats because of that awesome small book by Dave Gurnell - and actually this whole presentation was totally inspired by it
you can find it on shapeless github - and you can order 

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
name: chill-out1
class: background-cover
background-image: url(resources/astro-beer-no-label.jpg)

???
Let your types do work for you - so you can just get back, have a ball and chill out
Like this

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
name: chill-out2
class: background-cover
background-image: url(resources/astro-bong.jpg)

???
Or maybe.. like this 
<p><strong>FUN></strong>
..Whatever you prefer)

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
name: thanks

# Thanks

* ## [@twist522]()

* ## [blog.codefastdieyoung.xyz]()

* ## [github.com/thatwist]()

* ## [crossroadlabs.xyz]()

???

Small pieces of code from the presentation - you can find on the github page
So please follow me on whatever blablabla thanks for coming)

<!-- ------------------------------------------------------------------------------------------------------------ -->
---
count: false
template: chill-out1

???

<AUDITORY> BTW, Has anybody noticed anything wrong with this situation??)))
<AUDITORY> Here is a cookie for the right answer!! <CROSSROADS CUP / T-SHIRT ???>
- He is in space suite!! He can't drink that beer!!!)) Ha-Ha - take the cookie, you won))

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <!-- terminal highlight -->
    <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
    <script type="text/javascript">
      var hljs = remark.highlighter.engine;
    </script>
    <script src="terminal.language.js" type="text/javascript"></script>
    <!-- END terminal highlight -->
    <script>
      var slideshow = remark.create({
        highlightLines: true,
        highlightLanguage: 'scala',
        // highlightStyle: 'monokai'
        highlightStyle: 'ocean'
      });
      // extract the embedded styling from ansi spans
      $('code.terminal span.hljs-ansi').replaceWith(function(i, x) {
        return x.replace(/<(\/?(\w+).*?)>/g, '<$1>')
      });
    </script>
    //
    <script>
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-28956594-3']);
      _gaq.push(['_trackPageview']);
      (function() {
        var ga = document.createElement('script');
        ga.src = 'https://ssl.google-analytics.com/ga.js';
        var s = document.scripts[0];
        s.parentNode.insertBefore(ga, s);
      }());
    </script>
  </body>
</html>